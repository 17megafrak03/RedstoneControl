#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Steuerung
# Block Namen & Beschreibungen
tile.rs_ctr.rs_port\:0.name=Redstone-Einlesebuchse
tile.rs_ctr.rs_port\:0.tip=Liest das Redstone-Signal aus der Blockfläche auf der sie montiert ist.\nIst mit einer §6Ausgabebuchse§7 auf der selben Fläche kombinierbar.\n\nKann mit einem §asoliden Block§7 in der §alinken Hand§7 verdeckt werden.\nOder platziere sie mit der §alinken Hand§7 gegen einen §asoliden Block§7 um diesen durch eine abgedeckte §6Buchse§7 zu ersetzen. §oIm Überlebensmodus ist ein geeignetes Werkzeug in der rechten Hand erforderlich um den Block abzubauen.
tile.rs_ctr.rs_port\:1.name=Redstone-Ausgabebuchse
tile.rs_ctr.rs_port\:1.tip=Sendet ein Redstone-Signal in die Blockfläche auf der sie montiert ist.\nIst mit einer §6Einlesebuchse§7 oder einer weiteren §6Ausgabebuchse§7 auf der selben Fläche kombinierbar (2 Ausgabebuchsen kombiniert senden ein starkes Signal das solide Blöcke durchdringt).\n\nKann mit einem §asoliden Block§7 in der §alinken Hand§7 verdeckt werden.\nOder platziere sie mit der §alinken Hand§7 gegen einen §asoliden Block§7 um diesen durch eine abgedeckte §6Buchse§7 zu ersetzen. §oIm Überlebensmodus ist ein geeignetes Werkzeug in der rechten Hand erforderlich um den Block abzubauen.
tile.rs_ctr.splitter.name=4-fach Signalverteiler
tile.rs_ctr.splitter.tip=Kopiert das eingehende Signal auf vier Ausgänge (ohne Laufzeitverzögerung).
tile.rs_ctr.analog_comb.name=analoger Signalkombinator
tile.rs_ctr.analog_comb.tip=Kombiniert die 4 eingehenden Signale, indem es das mit dem größten Wert ausgibt.
tile.rs_ctr.logic_comb.name=logischer Signalkombinator
tile.rs_ctr.logic_comb.tip=Kombiniert die 4 eingehenden Signale durch logische §eODER§7-Verknüpfung, wobei die Werte §e65536§7 für §eWahr§7 und §e0§7 für §eFalsch§7 ausgegeben werden.\nDer Ausgang, sowie jeder Eingang können individuell invertiert werden, was auch die anderen Logikgattertypen §eUND§7, §enicht-UND§7 und §enicht-ODER§7 liefert.
tile.rs_ctr.num_comb.name=arithmetischer Signalkombinator
tile.rs_ctr.num_comb.tip=Kombiniert die 4 eingehenden Signale durch Addition.\nEingänge können negiert werden, was auch subtraktion ermöglicht.
tile.rs_ctr.bin_comb.name=binärer Signalpacker
tile.rs_ctr.bin_comb.tip=Das Ausgangssignal ergibt sich durch aneinanderreihung der Binärdarstellungen der 4 Eingangssignale. Es ist einstellbar, wie viele Bits jeweils von den Eingängen verwendet werden\:\n§e1 bit§7 unterscheidet nur zwischen §e0§7 und §e1\n§e2 bit§7 unterscheidet zwischen §e0§7, §e1§7, §e2§7 und §e3\n§e4 bit§7 unterscheidet die Werte §e0§7 - §e15\n§e8 bit§7 unterscheidet die Werte §e0§7 - §e255\n§oNur Werte innerhalb des entsprechenden Wertebereichs lassen sich später mit dem §6§obinären Signalentpacker§7§o verlustfrei zurückgewinnen.
tile.rs_ctr.bin_split.name=binärer Signalentpacker
tile.rs_ctr.bin_split.tip=Funktioniert genau umgekehrt zum §6binären Signalpacker§7\:\nDie Binärdarstellung des Eingangssignals wird in 4 Stücke je §e1§7, §e2§7, §e4§7 oder §e8 bit§7 (je nach Einstellung) zerlegt, welche dann die Ausgangssignale bilden.\n\n§oDies ermöglicht es, mehrere Signale durch eine gemeinsame Leitung zu schicken, sowie die Operation eines §6§ologischen Signalkombinator§7§os im §e§obitweise§7§o-Modus für alle gepackten Signale parallel durzuführen.
tile.rs_ctr.wire_anchor.name=Kabelhalter
tile.rs_ctr.wire_anchor.tip=§6Signalkabel§7 können and diesen angebracht werden um ihren Verlauf anzupassen.\n§oEs können mehrere davon im gleichen Block plaziert werden.
tile.rs_ctr.editor.name=Schaltplaneditor
tile.rs_ctr.editor.tip=Wird benutzt um §6Prozessor§7en zu programmieren.
tile.rs_ctr.processor.name=Redstone-Prozessor
tile.rs_ctr.processor.tip=Diese kompakte Schaltung kann im §6Schaltplaneditor§7 programmiert werden.\nBietet bis zu §16 Eingänge§7 und §26 Ausgänge§7.
tile.rs_ctr.comparator.name=getakteter Komparator
tile.rs_ctr.comparator.tip=Immer, wenn der Wert von §eTakt EIN§7 sich ändert, wird der Komparatorwert von §eBlock EIN§7 ausgelesen und §eAUS§7 auf diesen aktualisiert.\n§oDas Ausleseverhalten kann durch einbau bestimmter Items angepasst werden\: Siehe §9§oAnwendungsrezepte in JEI§7.
tile.rs_ctr.assembler.name=Prozessor Werkbank
tile.rs_ctr.assembler.tip=Hiermit können Komponenten zu einem §6Redstone Prozessor§7 hinzugefügt werden um dessen Komplexitätwerte zu erhöhen.
tile.rs_ctr.power_hub.name=Energieverteiler
tile.rs_ctr.power_hub.tip=Kann bis zu 8 angeschlossene Geräte mit Energie versorgen.\nAkzeptiert Forge kompatible Energie durch die Blockrückseite.\n§oBetrieb erfordert den Einbau separater Akkumulatoren\: Siehe §9§oAnwendungsrezepte in JEI§7.\n§oObwohl sie nicht gelistet sind, fungieren auch alle Forge-Energie kompatiblen Items als Akkumulator.

# Chat Hinweise
msg.rs_ctr.type=§cInkompatibler Anschlusstyp!
msg.rs_ctr.wire0=§cAusgänge können nur mit Eingängen verbunden werden und umgekehrt!
msg.rs_ctr.wire1=§cZu weit weg, nicht genug Kabel!
msg.rs_ctr.wire2=§cZu weit weg, maximale Distanz ist %dm!
msg.rs_ctr.wire3=§cDer erste Anschluss existiert nicht mehr!
msg.rs_ctr.const=§cKonstanten können nur an Eingänge angeschlossen werden!
msg.rs_ctr.lamp=§cLampen können nur an Ausgänge angeschlossen werden!
msg.rs_ctr.save_succ=§aSchaltplan erfolgreich gespeichert!
msg.rs_ctr.load_succ=§aSchaltplan erfolgreich geladen!
msg.rs_ctr.invalid_file=§cDie ausgewählte Datei enthält keine Schaltplan-daten!
msg.rs_ctr.no_file§cDie ausgewählte Datei existiert nicht!

# Item Namen & Beschreibungen
item.rs_ctr.wire.name=Signalkabel
item.rs_ctr.wire.tip=§aBenutze§7 nacheinander auf zwei Signalanschlüssen unterschiedlicher Polarität um sie miteinander zu verbinden.\n§oBenötigt 1 Kabel pro Block geradliniger Distanz.\n\nVerbindungen können durch §aschlagen§7 oder §ageducktes benutzen§7 mit §aleerer Hand§7 wieder entfernt werden.
item.rs_ctr.wireless.name=kabelloser Signalverbinder
item.rs_ctr.wireless.tip=Ein §6Signal"kabel"§7 welches zwei Anschlüsse über unbegrenzte Distanz verbinden kann.\nFunktioniert auch dimensionsübergreifend.
item.rs_ctr.constant.name=Konstantenstecker
item.rs_ctr.constant.tip=Kann an einen Signaleingang angeschlossen werden um ihn mit einem konstanten Signalwert zu versorgen.\n§aBenutze§7 in die Luft um den Signalwert einzustellen.
item.rs_ctr.lamp.name=Signalstatuslampe
item.rs_ctr.lamp.tip=Zeigt den Signalwert des Signalausgangs an, an den sie ansgeschlossen ist.
item.rs_ctr.tag.name=Kabelbeschrifter
item.rs_ctr.tag.tip=§aBenutze§7 in die Luft um den Namen einzustellen.\n§aBenutze§7 auf eine angeschlossenen Buchse um die Verbindung umzubenennen. Diese zeigt dann den Namen anstatt einer ID an.
item.rs_ctr.block_wire.name=Blockreferenzkabel
item.rs_ctr.block_wire.tip=Wird benutzt um Blockseiten an Geräte wie Sensoren anzuschließen.
item.rs_ctr.clock.name=Taktgeberstecker
item.rs_ctr.clock.tip=Gibt ein kontinuierliches Rechtecksignal in den Anschluss aus, in den er gesteckt ist. Signal wechselt zwischen §e65535§7 und §e0§7.\n§aBenutze§7 in die Luft um Pulsbreite und Phase einzustellen.\n§oAlle Taktgeber in einer Welt sind miteinander synchronisiert.
item.rs_ctr.wire_e.name=Energiekabel
item.rs_ctr.wire_e.tip=Verbindet Energieanschlüsse nach dem gleichen Prinzip, wie das §6Signalkabel§7 Signalanschlüsse verbindet.\n§oVerbraucht 1 Kabel pro Block geradliniger Distanz.
item.rs_ctr.processor.stats=Komplexität\: §c%d §b%d §9%d §7Größe\: §f%d
item.cd4017be.m\:battery.name=Redstone Batterie

#Signalanschluss namen
port.rs_ctr.rsR=Lesen
port.rs_ctr.rsW=Schreiben
port.rs_ctr.i=EIN
port.rs_ctr.i0=EIN 0\n§okleinste Signifikanz
port.rs_ctr.i1=EIN 1
port.rs_ctr.i2=EIN 2
port.rs_ctr.i3=EIN 3\n§ogrößte Signifikanz
port.rs_ctr.o=AUS
port.rs_ctr.o0=AUS 0\n§okleinste Signifikanz
port.rs_ctr.o1=AUS 1
port.rs_ctr.o2=AUS 2
port.rs_ctr.o3=AUS 3\n§ogrößte Signifikanz
port.rs_ctr.num0=positiv
port.rs_ctr.num1=negiert
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bitweise
port.rs_ctr.logic3=bitweise\ninvertiert
port.rs_ctr.logic4=ODER
port.rs_ctr.logic5=nicht-ODER
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit\n
port.rs_ctr.clk=Takt EIN
port.rs_ctr.bi=Block EIN
port.rs_ctr.energy_i=Energie EIN
port.rs_ctr.energy_o=Energie AUS
port.rs_ctr.battery0=§ckein Akkumulator\n§ceingebaut!
port.rs_ctr.battery=§aLadung\:\n§a%.4u / %.3u
sensor.rs_ctr.none=Komparatorwert
sensor.rs_ctr.item=enthaltene\nItemanzahl
sensor.rs_ctr.fluid=enthaltene\nFlüssigkeitsmenge [mB]
sensor.rs_ctr.fe=gespeicherte\nEnergie [RF]
sensor.rs_ctr.eu=gespeicherte\nEnergie [EU]

gate.cost=§8Komplexität\: §c%d §b%d
gategroup.rs_ctr.io=Variablen & E/A
gate.rs_ctr.in=Signaleingang\n§7Empfängt Signale von außen.
gate.rs_ctr.out=Signalausgang\n§7Sendet Signale nach außen.
gate.rs_ctr.i_cst=konstante Zahl\n§7A \= #
gate.rs_ctr.write=Variable schreiben\n§7Speichert den Eingangswert in einer Variable,\n§7um ihn an den nächsten Zyklus weiterzugeben.
gate.rs_ctr.read=Variable lesen\n§7Gibt den Wert einer Variable aus, der\n§7im vorherigen Zyklus gesetzt wurde.
gategroup.rs_ctr.logic=Logik
gate.rs_ctr.not=Nicht-Gatter\n§7A \= ¬E\n§7bitweise
gate.rs_ctr.or=Oder-Gatter\n§7A \= E1 ∨ E2\n§7bitweise
gate.rs_ctr.nand=Nicht-Und-Gatter\n§7A \= ¬(E1 ∧ E2)\n§7bitweise
gate.rs_ctr.xor=Exklusiv-Oder-Gatter\n§7A \= E1 ⊻ E2\n§7bitweise
gate.rs_ctr.nor=Nicht-Oder-Gatter\n§7A \= ¬(E1 ∨ E2)\n§7bitweise
gate.rs_ctr.and=Und-Gatter\n§7A \= E1 ∧ E2\n§7bitweise
gate.rs_ctr.xnor=Invers-Exklusiv-Oder-Gatter\n§7A \= ¬(E1 ⊻ E2)\n§7bitweise
gategroup.rs_ctr.comp=Komparatoren
gate.rs_ctr.is0=ist Null\n§7E \= 0 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.eq=gleich\n§7E1 \= E2 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.not0=nicht Null\n§7E \= 0 -> A \= 0\n§7sonst -> A \= -1
gate.rs_ctr.nsgn=ist negativ\n§7E < 0 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.psgn=nicht negativ\n§7E < 0 -> A \= 0\n§7sonst -> A \= -1
gate.rs_ctr.neq=ungleich\n§7E1 \= E2 -> A \= 0\n§7sonst -> A \= -1
gate.rs_ctr.ls=kleiner als\n§7E1 < E2 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.geq=größer/gleich\n§7E1 < E2 -> A \= 0\n§7sonst -> A \= -1
gategroup.rs_ctr.num=Arithmetik
gate.rs_ctr.inc=erhöhen\n§7A \= E + 1
gate.rs_ctr.dec=erniedrigen\n§7A \= E - 1
gate.rs_ctr.neg=negieren\n§7A \= -E
gate.rs_ctr.abs=Absolutbetrag\n§7E < 0 -> A \= -E\n§7sonst -> A \= E
gate.rs_ctr.add=addieren\n§7A \= E1 + E2
gate.rs_ctr.sub=subtrahieren\n§7A \= E1 - E2
gate.rs_ctr.mul=multiplizieren\n§7A \= E1 * E2
gate.rs_ctr.div=dividieren\n§7A \= E1 / E2\n§7A wird abgerundet\n§4§odiv/0 verursacht Ausfall!
gate.rs_ctr.mod=Divisionsrestwert\n§7A \= E1 mod E2\n§7A übernimmt Vorzeichen von E2\n§4§odiv/0 verursacht Ausfall!
gate.rs_ctr.max=Maximum\n§7E1 > E2 -> A \= E1\n§7sonst -> A \= E2
gate.rs_ctr.min=Minimum\n§7E1 < E2 -> A \= E1\n§7sonst -> A \= E2

# GUI
# Inventory names
gui.rs_ctr.constant.name=Signalwert:
gui.rs_ctr.tag.name=Beschriftung:
gui.rs_ctr.editor.name=Schaltplaneditor\:
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.state.name=Variablen:
gui.rs_ctr.clock.name=Einstellungen
gui.rs_ctr.assembler.name=Prozessor bearbeiten
# Gui tooltips
gui.rs_ctr.palette=Bauteilpalette
gui.rs_ctr.palette.open0=Bauteilpalette öffnen
gui.rs_ctr.palette.open1=Inventar öffen
gui.rs_ctr.opLabel=Beschriftung\n§7(relevant für\n§7Variablen & E/A)
gui.rs_ctr.value=Wert
gui.rs_ctr.interrupt0=Wertänderung triggert §nkeinen§r neuen Zyklus
gui.rs_ctr.interrupt1=Wertänderung triggert neuen Zyklus
gui.rs_ctr.editor.title=Name der Schaltung
gui.rs_ctr.editor.del=§4Bauteil löschen
gui.rs_ctr.editor.new=Neue Schaltung\n§4Löscht das Board
gui.rs_ctr.editor.compile=Schaltung Kompilieren\n§7+§aSHIFT§7\: Debugger öffen
gui.rs_ctr.editor.load=Schaltung importieren
gui.rs_ctr.editor.save=Schaltung exportieren\n§aR-C§7\:exportieren als ...
gui.rs_ctr.editor.ingreds=Schaltungskomplexität\:\n§c%d / %d einfach\n§b%d / %d erweitert\n§9%d / %d Speicher
gui.rs_ctr.editor.info=Bedienung\nallgemeine Funktionsweise\nDebugging / Testing
gui.rs_ctr.editor.info0=§7§nBauteilinteraktion\:§a links-Klick\n§7Um ein Bauteil hinzufügen, klicke es zunächst in der Palette an und platziere es durch einen weiteren Klick auf dem Board.\n§7§oDie Palette zeigt sich anstelle deines Inventars, wenn durch entsprechende Schaltfläche aktiviert.\n§aAnklicken§7 eines Bauteils auf dem Board wählt es aus\: Einstellungsoptionen erscheinen dann rechts unterhalb des Boards.\n§aKlick+ziehen§7 bewegt ein Bauteil [rote Rahmen zeigen Kollisionen mit anderen Bauteilen an].\n§7Bewegt man ein Bauteil außerhalb des Boardbereichs, so wird es gelöscht [hellroter Rahmen].\n§7§nAnschluss-/Leitungsinteraktion\:§a rechts-Klick\n§7Um zwei Bauteile mit einer Leitung zu verbinden, §aklicke§7 zuerst einen Eingangspin [linke Seite eines Bauteils] an, dann eventuell ein paar Punkte auf dem Board (um den Pfad anzupassen) und schließlich den Ausgangspin [rechte Seite] des anderen Bauteils.\n§aKlick+ziehe§7 eine Ecke eines Leitungspfads um sie nachträglich zu bewegen.
gui.rs_ctr.editor.info1=§7Ganz allgemein erhält eine Schaltung diverse Signale von externen Geräten durch seine §6Eingänge§7, führt dann ein par Berechnungen an diesen durch und erzeugt schließlich ein oder mehrere Ergebnisse, die durch seine §6Ausgänge§7 wieder zu externe Geräten weiter geschickt werden. Dieser Vorgang wird hier als §eein Zyklus§7 bezeichnet.\n\n§6Variablen§7 ermöglichen es einer Schaltung, auch auf Informationen aus vorherigen Zyklen zuzugreifen. Sie bestehen aus einer §6Schreib§7-komponente, die einen Wert in einem Zyklus erhält und speichert, sowie einer passenden [gleicher Name] §6Lese§7-Komponente, die diesen Wert dann einen Zyklus später wieder ausgibt. Die Lesekomponente bestimmt auch den Startwert der Variablen. \n\n§7Normalerweise wird ein neuer Zyklus mit einer 1-Tick Verzögerung ausgeführt, nachdem ein Eingangs- oder Variablenwert sich geändert hat. Aber du kanns auch individuell einstellen, dass bestimmte §6Variablen Schreiboperatoren§7 oder §6Eingängen§§§7§7 keinen neuen Zyklus triggern.\n§7§oHinweis\: Das manuelle ändern von Variablenwerten über den Debugger oder das Statusinterface eines Prozessors triggert auch keinen Zyklus.
gui.rs_ctr.editor.info2=§7Auch, wenn man die Schaltung auf einem §6Prozessor§7 beliebig oft überschreiben kanns, ist es normalerweise eine gute Idee, eine Schaltung erstmal mit dem §eDebugger§7 zu testen, bevor man sie an kritische Systeme anschließt.\n§7Das §eDebugger§7-Fenster wird durch §arechts-Klick§7 (anstatt links-Klick) auf die §eKompilieren Schaltfläche§7 geöffnet. Darin kann man die Schaltung mit beliebigen Eingangswerten füttern und beobachten, wie jeweils nach einzelnen Zyklen die Ausgangswerte und Variablenzustände reagieren.\n§7Die Funktion des Debuggers, Variablenwerte zu bearbeiten ist auch später im §eStatusinterface§7 des plazierten §6Prozessor§7s verfügbar.\n§7Somit können auch ansonsten scheinbar nutzlose §enur-lesen§7 oder §enur-schreiben§7 Variablen benutzt werden, um später Parameter zu justieren oder um mehr Details über die Funktion der Schaltung zu erhalten.
gui.rs_ctr.debug.run0=automatische Ausführung
gui.rs_ctr.debug.run1=manuelle Ausführung
gui.rs_ctr.debug.step0=Zyklus erzwingen\n§4§ostabiler Zustand
gui.rs_ctr.debug.step1=Einzelzyklus\n§2§oinstabiler Zustand
gui.rs_ctr.debug.reset=zurücksetzen
gui.rs_ctr.state.io=Signal E/A\:
gui.rs_ctr.hex0=Dezimalformat
gui.rs_ctr.hex1=Hexadezimalformat
gui.rs_ctr.interval=Interval
gui.rs_ctr.phase=Phasenverschiebung
gui.rs_ctr.error1=§4Kausalschleife
gui.rs_ctr.error2=§4inkompatibler Datentyp
gui.rs_ctr.error3=§4Eingang nicht angeschlossen
gui.rs_ctr.error4=§4ungültiger Variablenname
gui.rs_ctr.error5=§4variable ist mehrfach deklariert
gui.rs_ctr.error6=§4mehrfaches Schreiben auf gleiche Variable
gui.rs_ctr.error7=§4ungültiger Wert
gui.rs_ctr.error32=§4Prozessor benötigt
gui.rs_ctr.error33=§4Schaltung ist zu komplex\n§4für den Processor
gui.rs_ctr.error34=§4Prozessor unterstützt\nnicht ausreichend E/A Pins
gui.rs_ctr.error64=§6Es wird empfohlen, alle\n§6E/A-Anschlüsse zu beschriften.
gui.rs_ctr.save_file=exportieren
gui.rs_ctr.load_file=importieren
gui.rs_ctr.processor.run=Zyklus manuell triggern
gui.rs_ctr.processor.power=Redstone-Überlastung\:\n§e%.0f %%
gui.rs_ctr.assembler.stats=§c%d\n§b%d\n§9%d\n§f%d\n§e%.1f Zyk\n§a%.1f Z/s
gui.rs_ctr.assembler.stats4=§e%+d Kap
gui.rs_ctr.assembler.stats5=§a%+d E/t
gui.rs_ctr.assembler.info=Prozessoraufbau\nRedstone-Energie
gui.rs_ctr.assembler.info0=§7Komplexe Schaltungen erfordern auch komplexe Hardware§7.\n§7Es gibt 3 verschiedene Arten von §eKomplexität§7, die sich jeweils auf unterschiedliche Rechenoperationen beziehen und jeweils durch einbau bestimmter Komponenten in den §6Prozessor§7 erhöht werden können.\n§7Komponenten verbrauchen jedoch §ePlatz§7 auf dem Prozessor, der begrenzt ist.\n§7Dabei liefern unterschiedliche Komponenten nicht nur verschiedene Arten von §eKomplexität§7, sondern tun dies auch bei variierenden §ePlatz§7kosten und unterschiedlicher §eRedstone Energiestärke§7. §oSiehe nächste Seite.
gui.rs_ctr.assembler.info1=§7Es scheint, als würde §6Redstone§7 auf natürliche Weise, ohne erkennbare Energiequelle Ladung aufbauen. §oEs wird vermutet, dass dies auf radioaktiven Zerfall zurückzuführen ist.\n§7Diese Ladungen sind jedoch ziemlich schwach, gerade genug um einfache berechnungen mit Logikgattern zu betreiben. Schalten die Signale jedoch zu oft ist sie schnell erschöpft, was sich deutlich am Ausbrenneffekt von §6Redstone-Fackeln§7 zeigt.\n§7Bestimmte energetische Materialien können den Ladungsaufbau verstärken. Eine miniaturisierung von Schaltungen, sowie Reduktion von Materialkosten hingegen schwächt diesen stark, eventuell so weit, dass die Schaltung ohne externe Energieversorgung nicht mehr stabil betrieben werden kann.\n§7§oDies wird durch die Parameter §e§olängste Dauertaktfolge§7§o and §e§okontinuirliche Taktrate§7§o Charakterisiert.
gui.rs_ctr.mat3=verbleibender Platz
gui.rs_ctr.mat2=Speicher (Bytes)
gui.rs_ctr.mat1=erweiterte Komplexität
gui.rs_ctr.mat0=einfache Komplexität
gui.rs_ctr.mat5=kontinuierliche Taktrate
gui.rs_ctr.mat4=längste Dauertaktfolge

recipe.rs_ctr.circuit_mat=Prozessorkomponenten
recipe.rs_ctr.battery=Akkumulatoren
recipe.rs_ctr.sensors=Komparatorjustierungen
recipe.rs_ctr.capacity=%.4u Ladung
