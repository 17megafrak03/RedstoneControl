#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Steuerung
# Block Namen & Beschreibungen
tile.rs_ctr.rs_port\:0.name=Redstone-Einlesebuchse
tile.rs_ctr.rs_port\:0.tip=Liest das Redstone-Signal aus der Blockfläche auf der sie montiert ist.\nIst mit einer §6Ausgabebuchse§7 auf der selben Fläche kombinierbar.\n\nKann mit einem §asoliden Block§7 in der §alinken Hand§7 verdeckt werden.\nOder platziere sie mit der §alinken Hand§7 gegen einen §asoliden Block§7 um diesen durch eine abgedeckte §6Buchse§7 zu ersetzen. §oIm Überlebensmodus ist ein geeignetes Werkzeug in der rechten Hand erforderlich um den Block abzubauen.
tile.rs_ctr.rs_port\:1.name=Redstone-Ausgabebuchse
tile.rs_ctr.rs_port\:1.tip=Sendet ein Redstone-Signal in die Blockfläche auf der sie montiert ist.\nIst mit einer §6Einlesebuchse§7 oder einer weiteren §6Ausgabebuchse§7 auf der selben Fläche kombinierbar (2 Ausgabebuchsen kombiniert senden ein starkes Signal das solide Blöcke durchdringt).\n\nKann mit einem §asoliden Block§7 in der §alinken Hand§7 verdeckt werden.\nOder platziere sie mit der §alinken Hand§7 gegen einen §asoliden Block§7 um diesen durch eine abgedeckte §6Buchse§7 zu ersetzen. §oIm Überlebensmodus ist ein geeignetes Werkzeug in der rechten Hand erforderlich um den Block abzubauen.
tile.rs_ctr.splitter.name=4-fach Signalverteiler
tile.rs_ctr.splitter.tip=Kopiert das eingehende Signal auf vier Ausgänge (ohne Laufzeitverzögerung).
tile.rs_ctr.analog_comb.name=analoger Signalkombinator
tile.rs_ctr.analog_comb.tip=Kombiniert die 4 eingehenden Signale, indem es das mit dem größten Wert ausgibt.
tile.rs_ctr.logic_comb.name=logischer Signalkombinator
tile.rs_ctr.logic_comb.tip=Kombiniert die 4 eingehenden Signale durch logische §eODER§7-Verknüpfung, wobei die Werte §e65536§7 für §eWahr§7 und §e0§7 für §eFalsch§7 ausgegeben werden.\nDer Ausgang, sowie jeder Eingang können individuell invertiert werden, was auch die anderen Logikgattertypen §eUND§7, §enicht-UND§7 und §enicht-ODER§7 liefert.
tile.rs_ctr.num_comb.name=arithmetischer Signalkombinator
tile.rs_ctr.num_comb.tip=Kombiniert die 4 eingehenden Signale durch Addition.\nEingänge können negiert werden, was auch subtraktion ermöglicht.
tile.rs_ctr.bin_comb.name=binärer Signalpacker
tile.rs_ctr.bin_comb.tip=Das Ausgangssignal ergibt sich durch aneinanderreihung der Binärdarstellungen der 4 Eingangssignale. Es ist einstellbar, wie viele Bits jeweils von den Eingängen verwendet werden\:\n§e1 bit§7 unterscheidet nur zwischen §e0§7 und §e1\n§e2 bit§7 unterscheidet zwischen §e0§7, §e1§7, §e2§7 und §e3\n§e4 bit§7 unterscheidet die Werte §e0§7 - §e15\n§e8 bit§7 unterscheidet die Werte §e0§7 - §e255\n§oNur Werte innerhalb des entsprechenden Wertebereichs lassen sich später mit dem §6§obinären Signalentpacker§7§o verlustfrei zurückgewinnen.
tile.rs_ctr.bin_split.name=binärer Signalentpacker
tile.rs_ctr.bin_split.tip=Funktioniert genau umgekehrt zum §6binären Signalpacker§7\:\nDie Binärdarstellung des Eingangssignals wird in 4 Stücke je §e1§7, §e2§7, §e4§7 oder §e8 bit§7 (je nach Einstellung) zerlegt, welche dann die Ausgangssignale bilden.\n\n§oDies ermöglicht es, mehrere Signale durch eine gemeinsame Leitung zu schicken, sowie die Operation eines §6§ologischen Signalkombinator§7§os im §e§obitweise§7§o-Modus für alle gepackten Signale parallel durzuführen.
tile.rs_ctr.wire_anchor.name=Kabelhalter
tile.rs_ctr.wire_anchor.tip=§6Signalkabel§7 können and diesen angebracht werden um ihren Verlauf anzupassen.\n§oEs können mehrere davon im gleichen Block plaziert werden.
tile.rs_ctr.editor.name=Schaltplaneditor

# Chat Hinweise
msg.rs_ctr.wire0=§cAusgänge können nur mit Eingängen verbunden werden und umgekehrt!
msg.rs_ctr.wire1=§cZu weit weg, nicht genug Kabel!
msg.rs_ctr.wire2=§cZu weit weg, maximale Distanz ist %dm!
msg.rs_ctr.wire3=§cDer erste Anschluss existiert nicht mehr!
msg.rs_ctr.const=§cKonstanten können nur an Eingänge angeschlossen werden!

# Item Namen & Beschreibungen
item.rs_ctr.wire.name=Signalkabel
item.rs_ctr.wire.tip=§aBenutze§7 nacheinander auf zwei Signalanschlüssen unterschiedlicher Polarität um sie miteinander zu verbinden.\n§oBenötigt 1 Kabel pro Block geradliniger Distanz.\n\nVerbindungen können durch §aschlagen§7 oder §ageducktes benutzen§7 mit §aleerer Hand§7 wieder entfernt werden.
item.rs_ctr.wireless.name=kabelloser Signalverbinder
item.rs_ctr.wireless.tip=Ein §6Signal"kabel"§7 welches zwei Anschlüsse über unbegrenzte Distanz verbinden kann.\nFunktioniert auch dimensionsübergreifend.
item.rs_ctr.constant.name=Konstantenstecker
item.rs_ctr.constant.tip=Kann an einen Signaleingang angeschlossen werden um ihn mit einem konstanten Signalwert zu versorgen.\n§aBenutze§7 in die Luft um den Signalwert einzustellen.
item.rs_ctr.lamp.name=Signalstatuslampe
item.rs_ctr.lamp.tip=Zeigt den Signalwert des Signalausgangs an, an den sie ansgeschlossen ist.
item.rs_ctr.tag.name=Kabelbeschrifter
item.rs_ctr.tag.tip=§aBenutze§7 in die Luft um den Namen einzustellen.\n§aBenutze§7 auf eine angeschlossenen Buchse um die Signalverbindung umzubenennen. Diese zeigt dann den Namen anstatt einer ID an.

#Signalanschluss namen
port.rs_ctr.rsR=Lesen
port.rs_ctr.rsW=Schreiben
port.rs_ctr.i=EIN
port.rs_ctr.i0=EIN 0\n§okleinste Signifikanz
port.rs_ctr.i1=EIN 1
port.rs_ctr.i2=EIN 2
port.rs_ctr.i3=EIN 3\n§ogrößte Signifikanz
port.rs_ctr.o=AUS
port.rs_ctr.o0=AUS 0\n§okleinste Signifikanz
port.rs_ctr.o1=AUS 1
port.rs_ctr.o2=AUS 2
port.rs_ctr.o3=AUS 3\n§ogrößte Signifikanz
port.rs_ctr.num0=positiv
port.rs_ctr.num1=negiert
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bitweise
port.rs_ctr.logic3=bitweise\ninvertiert
port.rs_ctr.logic4=ODER
port.rs_ctr.logic5=nicht-ODER
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit\n

gategroup.rs_ctr.io=Variablen & E/A
gate.rs_ctr.in=Signaleingang\n§7Empfängt Signale von außen.
gate.rs_ctr.out=Signalausgang\n§7Sendet Signale nach außen.
gate.rs_ctr.i_cst=konstante Zahl\n§7A \= #
gate.rs_ctr.write=Variable schreiben\n§7Speichert den Eingangswert in einer Variable,\n§7um ihn an den nächsten Zyklus weiterzugeben.
gate.rs_ctr.read=Variable lesen\n§7Gibt den Wert einer Variable aus, der\n§7im vorherigen Zyklus gesetzt wurde.
gategroup.rs_ctr.logic=Logik
gate.rs_ctr.not=Nicht-Gatter\n§7A \= ¬E\n§7bitweise
gate.rs_ctr.or=Oder-Gatter\n§7A \= E1 ∨ E2\n§7bitweise
gate.rs_ctr.nand=Nicht-Und-Gatter\n§7A \= ¬(E1 ∧ E2)\n§7bitweise
gate.rs_ctr.xor=Exklusiv-Oder-Gatter\n§7A \= E1 ⊻ E2\n§7bitweise
gate.rs_ctr.nor=Nicht-Oder-Gatter\n§7A \= ¬(E1 ∨ E2)\n§7bitweise
gate.rs_ctr.and=Und-Gatter\n§7A \= E1 ∧ E2\n§7bitweise
gate.rs_ctr.xnor=Invers-Exklusiv-Oder-Gatter\n§7A \= ¬(E1 ⊻ E2)\n§7bitweise
gategroup.rs_ctr.comp=Komparatoren
gate.rs_ctr.is0=ist Null\n§7E \= 0 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.eq=gleich\n§7E1 \= E2 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.not0=nicht Null\n§7E \= 0 -> A \= 0\n§7sonst -> A \= -1
gate.rs_ctr.nsgn=ist negativ\n§7E < 0 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.psgn=nicht negativ\n§7E < 0 -> A \= 0\n§7sonst -> A \= -1
gate.rs_ctr.neq=ungleich\n§7E1 \= E2 -> A \= 0\n§7sonst -> A \= -1
gate.rs_ctr.ls=kleiner als\n§7E1 < E2 -> A \= -1\n§7sonst -> A \= 0
gate.rs_ctr.geq=größer/gleich\n§7E1 < E2 -> A \= 0\n§7sonst -> A \= -1
gategroup.rs_ctr.num=Arithmetik
gate.rs_ctr.inc=erhöhen\n§7A \= E + 1
gate.rs_ctr.dec=erniedrigen\n§7A \= E - 1
gate.rs_ctr.neg=negieren\n§7A \= -E
gate.rs_ctr.abs=Absolutbetrag\n§7E < 0 -> A \= -E\n§7sonst -> A \= E
gate.rs_ctr.add=addieren\n§7A \= E1 + E2
gate.rs_ctr.sub=subtrahieren\n§7A \= E1 - E2
gate.rs_ctr.mul=multiplizieren\n§7A \= E1 * E2
gate.rs_ctr.div=dividieren\n§7A \= E1 / E2\n§7A wird abgerundet\n§4§odiv/0 verursacht Ausfall!
gate.rs_ctr.mod=Divisionsrestwert\n§7A \= E1 mod E2\n§7A übernimmt Vorzeichen von E2\n§4§odiv/0 verursacht Ausfall!
gate.rs_ctr.max=Maximum\n§7E1 > E2 -> A \= E1\n§7sonst -> A \= E2
gate.rs_ctr.min=Minimum\n§7E1 < E2 -> A \= E1\n§7sonst -> A \= E2

# GUI
# Inventory names
gui.rs_ctr.constant.name=Signalwert:
gui.rs_ctr.tag.name=Beschriftung:
gui.rs_ctr.editor.name=Schaltplaneditor\:
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.state.name=Variablen:
# Gui tooltips
gui.rs_ctr.palette.open1=Inventar öffen
gui.rs_ctr.palette.open0=Bauteilpalette öffnen
gui.rs_ctr.interval=Interval
gui.rs_ctr.debug.run0=automatische Ausführung
gui.rs_ctr.debug.run1=manuelle Ausführung
gui.rs_ctr.debug.step0=Zyklus erzwingen\n§4§ostabiler Zustand
gui.rs_ctr.debug.step1=Einzelzyklus\n§2§oinstabiler Zustand
gui.rs_ctr.debug.reset=zurücksetzen
gui.rs_ctr.state.io=Signal E/A\:
gui.rs_ctr.hex0=Dezimalformat
gui.rs_ctr.hex1=Hexadezimalformat
gui.rs_ctr.error1=§4Kausalschleife
gui.rs_ctr.error2=§4inkompatibler Datentyp
gui.rs_ctr.error3=§4Eingang nicht angeschlossen
gui.rs_ctr.error4=§4ungültiger Variablenname
gui.rs_ctr.error5=§4variable ist mehrfach deklariert
gui.rs_ctr.error6=§4mehrfaches Schreiben auf gleiche Variable
gui.rs_ctr.error7=§4ungültiger Wert
gui.rs_ctr.error32=§4Platine benötigt
gui.rs_ctr.opLabel=Beschriftung\n§7(relevant für\n§7Variablen & E/A)
gui.rs_ctr.value=Wert
gui.rs_ctr.interrupt0=Wertänderung triggert §nkeinen§r neuen Zyklus
gui.rs_ctr.interrupt1=Wertänderung triggert neuen Zyklus
gui.rs_ctr.editor.del=§4Bauteil löschen
gui.rs_ctr.editor.title=Name der Schaltung
gui.rs_ctr.editor.compile=Schaltung Compilieren\n§7+§aSHIFT§7\: Debugger öffen
gui.rs_ctr.editor.load=Schaltung importieren
gui.rs_ctr.editor.save=Schaltung exportieren
gui.rs_ctr.editor.new=Neue Schaltung\n§4Löscht das Board
gui.rs_ctr.palette=Bauteilpalette
