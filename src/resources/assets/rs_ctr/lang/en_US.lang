#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Control
# Blocks
# names & tooltips
tile.rs_ctr.rs_port\:0.name=Redstone Read Socket
tile.rs_ctr.rs_port\:0.tip=Attach on block surface to read its emitted Redstone signal.\nCan be combined with other §6Socket§7s on the same surface.\n§b§oSee also\: §6§oSignal ...\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:1.name=Redstone Write Socket
tile.rs_ctr.rs_port\:1.tip=Attach on block surface to control the Redstone signal it receives.\nCan be combined with other §6Socket§7s including another §6Write Socket§7 on the same surface (two Write Sockets combined will emit a strong signal that penetrates solid blocks).\n§b§oSee also\: §6§oSignal ...\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:2.name=Block Access Socket
tile.rs_ctr.rs_port\:2.tip=Attach on block surface to let connected devices interact with it.\nCan be combined with other §6Socket§7s on the same surface.\n§b§oSee also\: §6§oBlock Reference ...\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:3.name=Block Mirror Socket
tile.rs_ctr.rs_port\:3.tip=Attach on block to let it access the mirrored §9inventory§7 and §9fluid storage§7 of a connected block through this socket.\nCan be combined with other §6Socket§7s on the same surface.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.splitter.name=Signal 4x Splitter
tile.rs_ctr.splitter.tip=Repeats the incoming signal to four different destinations (no delay).
tile.rs_ctr.analog_comb.name=Analog Signal Combiner
tile.rs_ctr.analog_comb.tip=Combines the 4 incoming signals by outputing the one with highest value.
tile.rs_ctr.logic_comb.name=Logic Signal Combiner
tile.rs_ctr.logic_comb.tip=Combines the four incomming signals by logical §eOR§7, where the outputs will emit §e65536§7 for §etrue§7 and §e0§7 for §efalse§7.\nThe output as well as each individual input can be set to inverted which also gives you the other logic-gate types §eAND§7, §eNAND§7 and §eNOR§7.
tile.rs_ctr.xor_gate.name=XOR-Gate
tile.rs_ctr.xor_gate.tip=Combines the four incomming signals by §eExclusive-OR§7, where the outputs will emit §e65536§7 if an §eodd number§7 of inputs is §etrue§7 and §e0§7 otherwise.
tile.rs_ctr.num_comb.name=Arithmetic Signal Combiner
tile.rs_ctr.num_comb.tip=Combines the 4 incomming signals by adding their values together.\nInputs can be negated which allows computing subtractions too.
tile.rs_ctr.bin_comb.name=Binary Signal Packer
tile.rs_ctr.bin_comb.tip=The output signal results from concatenating the binary representations of the 4 input signals. How many bits are taken from each input signal is configurable\:\n§e1 bit§7 only distinguishes between §e0§7 and §e1\\n§e2 bit§7 distinguishes between §e0§7, §e1§7, §e2§7 und §e3\\n§e4 bit§7 distinguishes the values §e0§7 - §e15\\n§e8 bit§7 distinguishes the values §e0§7 - §e255\n§oOnly values within the given range can be losslessly retrieved later on by a §6§oBinary Signal Unpacker§7§o.
tile.rs_ctr.bin_split.name=Binary Signal Unpacker
tile.rs_ctr.bin_split.tip=Works the opposite way of the §6Binary Signal Packer§7\:\nThe binary representation of the input signal is split into 4 pieces of §e1§7, §e2§7, §e4§7 or §e8 bit§7 each (depending on setting) which then form the individual output signals.\n\n§oThis makes it possible to send multiple signals through a shared wire. Also the operation of a §6§oLogic Signal Combiner§7§o in §e§obitwise§7§o-mode runs for all packed signals in parallel.
tile.rs_ctr.wire_anchor.name=Wire Anchor
tile.rs_ctr.wire_anchor.tip=§6Signal Wire§7s can be attached on these to customize their path.\n§oMultiple of them may be placed inside a single block.
tile.rs_ctr.processor.tip=Compact circuit that's programmable with the §6Circuit Designer§7.\nOffers up to §16 Input§7 and §26 Output§7 ports but has less component capacity than the §eDIP8§7 version.
tile.rs_ctr.processor.name=Redstone Processor §eQFP12
tile.rs_ctr.editor.name=Circuit Designer
tile.rs_ctr.editor.tip=Used to program assembled §6Processor§7s.
tile.rs_ctr.comparator.name=clocked Comparator
tile.rs_ctr.comparator.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current comparator value read from §eBlock IN§7.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket\n\nThis device can be tuned to observe different block properties by attaching certain items on it\: See §9§oJEI usage recipes§7.
tile.rs_ctr.processor2.name=Redstone Processor §eDIP8
tile.rs_ctr.processor2.tip=Compact circuit that's programmable with the §6Circuit Designer§7.\nOffers up to §14 Input§7 and §24 Output§7 ports.
tile.rs_ctr.assembler.name=Processor Assembler
tile.rs_ctr.assembler.tip=Lets you add materials to a §6Redstone Processor§7 to improve its complexity values.
tile.rs_ctr.power_hub.name=Energy Distributor
tile.rs_ctr.power_hub.tip=Provides energy for up to 8 attached devices.\nAcceps Forge Energy compatible power through the block's back side.\n§oOnly works with capacitors installed\: See §9§oJEI usage recipes§7.\n§oAlthough not listed, all Forge Energy compatible items can be used as well.
tile.rs_ctr.item_translocator.name=Item Translocator
tile.rs_ctr.item_translocator.tip=§esource/destin. Inventory IN§7\: the inventory to take from / put in.\n§esource/destin. Slot IN§7\: the inventory's slot ID to interact with.\n§EAmount IN§7\: the number of items to transfer. §oNegative value will transfer destin. -> source instead.\n§eClock IN§7 triggers the transfer on value change.\n§eAmount OUT§7 returns number of items actually transfered.\n§eEnergy IN§7 supplies the energy required for operation.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket
tile.rs_ctr.fluid_translocator.name=Fluid Translocator
tile.rs_ctr.fluid_translocator.tip=§esource/destin. Tank IN§7\: the tank to drain from / fill in.\n§EAmount IN§7\: the fluid volume in mB to transfer. §oNegative value will transfer destin. -> source instead.\n§eClock IN§7 triggers the transfer on value change.\n§eAmount OUT§7 returns volume actually transfered.\n§eEnergy IN§7 supplies the energy required for operation.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket
tile.rs_ctr.panel.name=Control Panel
tile.rs_ctr.panel.tip=The surface is divided into a 4x4 grid where different §6Modules§7 can be attached. Ports for connecting wires to those Modules are on the back side.\nUse a §6Screwdriver§7 to configure or remove modules.\n§oAll installed Modules and configuration is kept when broken.
tile.rs_ctr.solar_cell.name=Solar Cell
tile.rs_ctr.solar_cell.tip=Generates energy from sunlight\nto power your pocket calculator.
tile.rs_ctr.energy_valve.name=Power Regulator
tile.rs_ctr.energy_valve.tip=Controls and measures the amount of §9Forge Energy§7 transfered through the device\:\nChanging the value of §eClock IN§7 starts a new Energy Packet of size §eRF Limit IN§7 and §eRF flow OUT§7 returns the amount that was transfered from the previous Packet.
tile.rs_ctr.splitter_b.name=Block Reference 4x Splitter
tile.rs_ctr.splitter_b.tip=Repeats the incoming §6Block Reference§7 to four different destinations (no delay).
tile.rs_ctr.multiplex_b.name=Block Reference Multiplexer
tile.rs_ctr.multiplex_b.tip=Selects one of the four §6Block Reference§7 inputs to pass on as output depending on the value of §eSelect IN§7 if it's in range §e0 ... 3§7. Otherwise outputs no Block Reference.

# chat messages
msg.rs_ctr.type=§cIncompatible socket type!
msg.rs_ctr.wire0=§cInputs can only connect to outputs and vice versa!
msg.rs_ctr.wire1=§cToo far away, not enough wire!
msg.rs_ctr.wire2=§cToo far away, max length is %d blocks!
msg.rs_ctr.wire3=§cFirst port doesn't exist anymore!
msg.rs_ctr.const=§cConstants can only connect to inputs!
msg.rs_ctr.lamp=§cLamps can only connect to outputs!
msg.rs_ctr.probe0=§cMust be connected to block first!
msg.rs_ctr.probe1=§cCan only connect to Block Reference inputs!
msg.rs_ctr.save_succ=§aCircuit Schematic successfully saved!
msg.rs_ctr.load_succ=§aCircuit Schematic successfully loaded!
msg.rs_ctr.invalid_file=§cThe selected file does'nt contain Circuit Schematic data!
msg.rs_ctr.no_file=§cThe selected file does'nt exist!
msg.rs_ctr.cfg_store=§2Configuration stored
msg.rs_ctr.cfg_load=§2Configuration loaded
msg.rs_ctr.copy_clr=§1Configuration cleared
msg.rs_ctr.cfg_invalid=§4Invalid configuration for component!

# Items
# names & tooltips
item.rs_ctr.wire.name=Signal Wire
item.rs_ctr.wire.tip=§aUse§7 on signal port to attach, then §ause§7 on another signal port of opposite polarity to connect both together.\n§oRequires 1 item per block of straight distance between ports.\n\nConnections are removed by either §ahitting§7 the port or §asneak using§7 it with an §aempty hand§7.
item.rs_ctr.wireless.name=Wireless Signal Connector
item.rs_ctr.wireless.tip=Like a §6Signal Wire§7 but can connect two signal ports over any distance, even across dimensions.
item.rs_ctr.constant.tip=Can be attached to an input port to supply it with a constant signal value.\n§aUse§7 in air to configure value.
item.rs_ctr.constant.name=Constant Plug
item.rs_ctr.lamp.name=Signal Status Lamp
item.rs_ctr.lamp.tip=Attach on output port to see its signal state.\n\nCan also be attached on a §6Control Panel§7 as indicator lamp.\n§eWidth\:§7 1  §eHeight\:§7 1\n§ePlacements\:§7 anywhere 4x4
item.rs_ctr.tag.name=Wire Tag
item.rs_ctr.tag.tip=§aUse§7 in air to set name.\n§aUse§7 on connected port to rename its wire connection. It will then show the name instead of an ID.
item.rs_ctr.block_wire.name=Block Reference Wire
item.rs_ctr.block_wire.tip=Connects §6Block Reference§7 ports just like the §6Signal Wire§7 connects signal ports.\n§oConsumes 1 item per block of straight distance between ports.\n§b§oSee also\: §6§oBlock Access Socket
item.rs_ctr.clock.name=Clock Plug
item.rs_ctr.clock.tip=Emits a continuous square-wave singal into the port it's attached to. Switching between §e65535§7 and §e0§7.\n§aUse§7 in air configure pulse width and phase.\n§oAll clocks in the world are synchronized.
item.rs_ctr.wire_e.name=Energy Wire
item.rs_ctr.wire_e.tip=Connects energy ports just like the §6Signal Wire§7 connects signal ports.\n§oConsumes 1 item per block of straight distance between ports.
item.rs_ctr.processor.stats=Complexity\: §c%d §b%d §9%d §7Size\: §f%d
item.rs_ctr.wrench.name=Screwdriver
item.rs_ctr.wrench.name1=Screwdriver §9stored conf.
item.rs_ctr.wrench.tip=§aUse§7 on §6Control Panel§7 to edit a module's configuration.\n§aHit§7 on §6Control Panel§7 to remove a module (works in creative, too).\n§aSneak-use§7 on §6Control Panel§7 to copy a module's configuration. §nThen\:\n§aUse§7 to apply the copied configuration on a module.\n§aSneak-use§7 in air to clear the copied configuration.
item.rs_ctr.seg7.name=7-Segment Display Module
item.rs_ctr.seg7.tip=A 4-digit 7-Segment LED-Display Module to attach on a §6Control Panel§7.\nProvides integrated encoder logic for decimal and hexadecimal. The §eOUT§7 signal can be used to chain multiple modules together to display bigger numbers.\n§eWidth\: §74  §eHeight\:§7 2\n§ePlacements\:§7 Top, Center, Bottom
item.rs_ctr.pointer_dsp.name=Analog Display Module
item.rs_ctr.pointer_dsp.tip=An analog pointer based display module to attach on a §6Control Panel§7.\nThe scale can be a quarter or full circle and its range is freely adjustable.\n§eWidth\:§7 4  §eHeight\:§7 4\n§ePlacements\:§7 Center
item.rs_ctr.slider.name=Slider Module
item.rs_ctr.slider.tip=A slider module to attach on a §6Control Panel§7 that allows continuous selection of values in a configurable range.\n§aInteract§7 with the upper section of the scale for fine control.\n§eWidth\: §74  §eHeight\:§7 2\n§ePlacements\:§7 Top, Center, Bottom
item.rs_ctr.text\:1.name=1/4 Text Module
item.rs_ctr.text\:2.name=1/2 Text Module
item.rs_ctr.text\:3.name=3/4 Text Module
item.rs_ctr.text\:4.name=full Text Module
item.rs_ctr.text\:i.tip=Displays 4 lines of text on a §6Control Panel§7.\n§eWidth\:§7 \\i  §eHeight\:§7 1\n§ePlacements\:§7 anywhere 4x4
item.rs_ctr.lever\:0.name=Lever Module
item.rs_ctr.lever\:1.name=Lamp-Switch Module
item.rs_ctr.lever\:2.name=Lamp-Button Module
item.rs_ctr.lever\:i.tip=Switches between two signal states when §aclicked§7.\nTo be attached on a §6Control Panel§7.\n§eWidth\:§7 1  §eHeight\:§7 1\n§ePlacement\:§7 anywhere 4x4
item.rs_ctr.lever\:2.tip=Stays ON after being §aclicked§7 for a configurable time interval.\n§aSneak-click§7 to turn off early.\nTo be attached on a §6Control Panel§7.\n§eWidth\:§7 1  §eHeight\:§7 1\n§ePlacements\:§7 anywhere 4x4
item.cd4017be.m\:battery.name=Redstone Battery
item.cd4017be.m\:actuator.name=Telekinetic Actuator
item.cd4017be.m\:telekin_alloy.name=Telekinetic Alloy

#Signal port names
port.rs_ctr.rsR=Read
port.rs_ctr.rsW=Write
port.rs_ctr.i=IN
port.rs_ctr.i0=IN 0\n§oleast significant
port.rs_ctr.i1=IN 1
port.rs_ctr.i2=IN 2
port.rs_ctr.i3=IN 3\n§omost significant
port.rs_ctr.o=OUT
port.rs_ctr.o0=OUT 0\n§oleast significant
port.rs_ctr.o1=OUT 1
port.rs_ctr.o2=OUT 2
port.rs_ctr.o3=OUT 3\n§omost significant
port.rs_ctr.num0=positive
port.rs_ctr.num1=negative
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bit-wise
port.rs_ctr.logic3=bit-wise\ninverted
port.rs_ctr.logic4=OR
port.rs_ctr.logic5=NOR
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit
port.rs_ctr.clk=Clock IN
port.rs_ctr.bi=Block IN
port.rs_ctr.clock=⎍ %.2fs
port.rs_ctr.energy_io=Energy I/O
port.rs_ctr.energy_i=Energy IN
port.rs_ctr.energy_o=Energy OUT
port.rs_ctr.battery0=§cno capacitor\n§cinstalled!
port.rs_ctr.battery=§aCharge\:\n§a%.4u / %.3u
port.rs_ctr.inv0=source Inventory IN
port.rs_ctr.inv1=destin. Inventory IN
port.rs_ctr.slot0=source Slot IN
port.rs_ctr.slot1=destin. Slot IN
port.rs_ctr.am_i=Amount IN
port.rs_ctr.am_o=Amount OUT
port.rs_ctr.cfg=Configuration
port.rs_ctr.tank0=source Tank IN
port.rs_ctr.tank1=destin. Tank IN
port.rs_ctr.rf_i=RF Limit IN
port.rs_ctr.rf_o=RF Flow OUT
port.rs_ctr.brR=Get Block OUT
port.rs_ctr.brW=Mirror Block IN
port.rs_ctr.bi0=Block IN 0
port.rs_ctr.bi1=Block IN 1
port.rs_ctr.bi2=Block IN 2
port.rs_ctr.bi3=Block IN 3
port.rs_ctr.bo=Block OUT
port.rs_ctr.sel=Select IN
sensor.rs_ctr.none=Comparator\nValue
sensor.rs_ctr.item=Stored Item Count
sensor.rs_ctr.fluid=Stored Fluid [mB]
sensor.rs_ctr.fe=Stored Energy [RF]
sensor.rs_ctr.eu=Stored Energy [EU]
sensor.rs_ctr.dfr-2=Draconic Fusion Reactor\n[°C, RF/‰, ∑mB/‰] +/-
sensor.rs_ctr.dfr-1=Draconic Fusion Reactor\n§7no Stabilizer or Injector connected!
sensor.rs_ctr.dfr0=temperature mode:\nTemperature [°C]
sensor.rs_ctr.dfr1=inverted temperature mode:\nStatus {-1:cold, 0:offline, 1:savety, 2:normal, 3:overheat}
sensor.rs_ctr.dfr2=containment field mode:\nField Charge [RF]
sensor.rs_ctr.dfr3=inverted containment field mode:\nField Strenght [0...1000]
sensor.rs_ctr.dfr4=core saturation mode:\nCore Charge [RF]
sensor.rs_ctr.dfr5=inverted core saturation mode:\nCore Saturation [0...1000]
sensor.rs_ctr.dfr6=fuel mode:\nTotal Core Mass [mB]
sensor.rs_ctr.dfr7=inverted fuel mode:\nFuel Conversion [0...1000]

#Circuit gates
gate.cost=§8Complexity\: §c%d §b%d
gategroup.rs_ctr.io=Memory & IO
gate.rs_ctr.in=Input Socket\n§7receives external sinals
gate.rs_ctr.out=Output Socket\n§7emits external signals
gate.rs_ctr.return=Execution End Node\n§7Ensures that the connected\n§7signal is evaluated.
gate.rs_ctr.read_b=Variable Read 8bit\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.read_s=Variable Read 16bit\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.read=Variable Read 32bit\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.write_b=Variable Write 8bit\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.write_s=Variable Write 16bit\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.write=Variable Write 32bit\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.feedback=Feedback Loop 32bit\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.feedback_b=Feedback Loop 8bit\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.feedback_s=Feedback Loop 16bit\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.array_b=Array 8bit\n§7Provides a fixed sized indexable list\n§7of persistent 8bit integer values.
gate.rs_ctr.array_s=Array 16bit\n§7Provides a fixed sized indexable list\n§7of persistent 16bit integer values.
gate.rs_ctr.array_i=Array 32bit\n§7Provides a fixed sized indexable list\n§7of persistent 32bit integer values.
gate.rs_ctr.aset=Array Write\n§7Writes in1 into index in2 in array in3.\n§7Valid indices are §e0 ... N-1§7 for array size N.\n§4§oAccessing an invalid index causes burnout!\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.aget=Array Read\n§7Reads the value at index in1 in array in2.\n§7Valid indices are §e0 ... N-1§7 for array size N.\n§4§oAccessing an invalid index causes burnout!
gate.rs_ctr.alen=Array Size\n§7Outputs the element count\n§7of the input array.
gategroup.rs_ctr.logic=Logic
gate.rs_ctr.or=OR-Gate\n§7out \= in1 ∨ in2\n§7bitwise
gate.rs_ctr.nand=NAND-Gate\n§7out \= ¬(in1 ∧ in2)\n§7bitwise
gate.rs_ctr.xor=XOR-Gate\n§7out \= in1 ⊻ in2\n§7bitwise
gate.rs_ctr.nor=NOR-Gate\n§7in \= ¬(in1 ∨ in2)\n§7bitwise
gate.rs_ctr.not=NOT-Gate\n§7out \= ¬in\n§7bitwise
gate.rs_ctr.and=AND-Gate\n§7out \= in1 ∧ in2\n§7bitwise
gate.rs_ctr.xnor=XNOR-Gate\n§7in \= ¬(in1 ⊻ in2)\n§7bitwise
gate.rs_ctr.swt=Switch\n§7in1 \= true -> out \= in2\n§7else -> out \= in3
gate.rs_ctr.branch=Execution Switch\n§7in1 \= true -> evaluate in2\n§7else -> evaluate in3
gate.rs_ctr.sequence=Execution Sequence\n§7first evaluate in1\n§7then evaluate in2
gate.rs_ctr.update=Update Trigger\n§7Always triggers the next\n§7cycle when evaluated.
gategroup.rs_ctr.comp=Comparators
gate.rs_ctr.lt0=Is Negative\n§7in < 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ge0=Not Negative\n§7in < 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.gt0=Is Positive\n§7in > 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.le0=Not Positive\n§7in > 0 -> out \= false\n§7else -> out \= true
gate.rs_ctr.eq0=Is Zero\n§7in \= 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ne0=Not Zero\n§7in \= 0 -> out \= false\n§7else -> out \= true
gate.rs_ctr.ne=Not Equal\n§7in1 \= in2 -> out \= false\n§7else -> out \= true
gate.rs_ctr.lt=Less than\n§7in1 < in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.eq=Equal\n§7in1 \= in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ge=Greater or Equal\n§7in1 < in2 -> out \= false\n§7else -> out \= true
gategroup.rs_ctr.num=Arithmetic
gate.rs_ctr.cst=Constant Number\n§7out \= #
gate.rs_ctr.neg=Negate\n§7out \= -in
gate.rs_ctr.sub=Subtract\n§7out \= in1 - in2
gate.rs_ctr.add=Add\n§7out \= in1 + in2
gate.rs_ctr.div=Divide\n§7out \= in1 / in2\n§7rounding down\n§4§oDiv/0 causes burnout!
gate.rs_ctr.dec=Decrement\n§7out \= in - 1
gate.rs_ctr.abs=Absolute value\n§7in < 0 -> out \= -in\n§7else -> out \= in
gate.rs_ctr.mul=Multiply\n§7out \= in1 * in2
gate.rs_ctr.inc=Increment\n§7out \= in + 1
gate.rs_ctr.mod=Div Remainder\n§7out \= in1 mod in2\n§7sgn(out) \= sgn(in1)\n§4§oDiv/0 causes burnout!
gate.rs_ctr.min=Minimum\n§7in1 < in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.max=Maximum\n§7in1 > in2 -> out \= in1\n§7else -> out \= in2
gategroup.rs_ctr.bin=Bits & Bytes
gate.rs_ctr.bsl=Bit left shift\n§7out \= in1 * 2^in2
gate.rs_ctr.bsr=Bit right shift\n§7out \= in1 / 2^in2
gate.rs_ctr.bitspl=Bit Splitter\n§7Splits an 8-bit input value up into its individual bits.\n§7Ouputs §etrue§7 or §efalse§7 depending on whether the bit is set.
gate.rs_ctr.bitcom=Bit Combiner\n§7Composes an 8-bit output\n§7value from individual bits.
gate.rs_ctr.bytespl=Byte Splitter\n§7Splits a 32-bit number into four\n§7signed or unsigned 8-bit numbers.
gate.rs_ctr.bytecom=Byte Combiner\n§7Combines four 8-bit numbers into one 32-bit number.\n§7§oIgnoring any higher order bits of the inputs.

# GUI
# Inventory names
gui.rs_ctr.constant.name=Set Value
gui.rs_ctr.tag.name=Label:
gui.rs_ctr.editor.name=Circuit Editor\:
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.state.name=Variables:
gui.rs_ctr.clock.name=Clock Settings
gui.rs_ctr.assembler.name=Processor Assembler
gui.rs_ctr.dsp_cfg.name=Configuration
# Gui tooltips
gui.rs_ctr.palette=Gate Palette
gui.rs_ctr.palette.open0=Open Gate Palette
gui.rs_ctr.palette.open1=Open Inventory
gui.rs_ctr.opLabel=Gate Label\n§7(relevant for\n§7variables & IO)
gui.rs_ctr.value=Value
gui.rs_ctr.interrupt0=changed value §ndoes not§r trigger next cycle
gui.rs_ctr.interrupt1=changed value triggers next cycle
gui.rs_ctr.signed0=Unsigned
gui.rs_ctr.signed1=Signed
gui.rs_ctr.array_len=Number of Entries
gui.rs_ctr.array_idx=index
gui.rs_ctr.editor.title=Name of your circuit
gui.rs_ctr.editor.del=§4delete Gate
gui.rs_ctr.editor.new=New Schematic\n§4clears the board
gui.rs_ctr.editor.compile=Compile Circuit\n§aR-C§7\: Debugger
gui.rs_ctr.editor.load=Import Schematic
gui.rs_ctr.editor.save=Save Schematic\n§aR-C§7\: export as ...
gui.rs_ctr.editor.ingreds=Circuit Complexity\:\n§c%d / %d basic\n§b%d / %d advanced\n§9%d / %d memory
gui.rs_ctr.editor.info=Controls\nBasic Mechanics\nSignal Types\nDebugging / Testing
gui.rs_ctr.editor.info0=§7§nComponent interaction\:§a left-click\n§7To add a component, first click on it in the palette, then on the board where you want to place it.\n§7§oThe palette shows up in place of your inventory when enabled via button.\n§aclick§7 on a component on the board to select it. Configuration options will appear below the bottom left of the boeard.\n§aclick-drag§7 to move a component around [red boxes indicate collision with other components].\n§7Moving a component outside the board area will delete it [bright red box].\n§7§nPin/Trace interaction\:§a right-click\n§7To connect two components with a trace, first §aclick§7 an input pin [left side of a component], then optinally click a few places on the board to lay out its path and finally §aclick§7 another component's output pin [right side].\n§aclick-drag§7 a trace vertex to move it.\n§aHold Alt§7 to display traces only.
gui.rs_ctr.editor.info1=§7In general a circuit receives signals from external devices through its §6input sockets§7, performs some computations on them and produces one or more results that get send back to external devices through its §6output sockets§7. This is refered to as a §ecycle§7.\n\n§6Variables§7 allow a circuit to remember information across cycles. They consist of a §6write§7 component that receives a value in one cycle and a matching [same label] §6read§7 component that spits it out again one cycle later. The read component also defines the variable's initial value. \n\n§7Normally a new cycle gets evaluated with one tick delay after an input or a variable changed its value. But you can set individual §6variable write§7s or §6input§7s to not trigger a cycle if wanted.\n§7§oNote\: changing variable values manually through the Debugger or the processor's status interface won't trigger a cycle.
gui.rs_ctr.editor.info2=§7Traces have different colors to indicate the type of signal being propagated which is determined by the component pins being connected\:\n§4§n32-bit integer§7\: standart number type also used by all redstone sockets. Has a valid range of §a-2147483648 ... 2147483647§7.\n§5§n8/16-bit integer§7\: supports a of range §a-128 ... 127§7 (signed) or §a0 ... 255§7 (unsigned) for 8 bit and §a-32768 ... 32767§7 (signed) or §a0 ... 65536§7 (unsigned) for 16 bit.\n§9§nboolean§7\: a logical signal that's either §atrue§7 or §afalse§7. When used for integer inputs, §atrue -> -1§7 and §afalse -> 0§7, conversion in the other direction uses §anon zero§7 comparison.\n§6§nfloating point§7\: represents fractional numbers, conversion rounds to nearest integer.\n§8§ncausal relation§7\: propagates no data, only controls execution flow.\n§e§narray§7\: reference to an integrated §lR§7andom §lA§7ccess §lM§7emory to be used with §eget§7 and §eset§7 operations.
gui.rs_ctr.editor.info3=§7Although you can overwrite the circuit on a §6processor§7 as often as you like, it is usually a good idea to first test your design with the §edebugger§7 before hooking it up to ... let's say, your nuclear reactor control setup.\n§7The §edebugger§7 window is opened by §aright-click§7 on the §ecompile button§7 (instead of left-click). In there you can feed your circuit with different input values and see how its outputs and variable states behave after executing individual cycles.\n§7The debugger's variable editing feature is also available later in the §6processor§7's §estatus interface§7 (which is opened by normal interaction with the placed block).\n§7Therefore also seemingly useless §eread-only§7 and §ewrite-only§7 variables may be used for later adjustment of parameters or getting more details about the circuit's operation.
gui.rs_ctr.debug.run0=automatic execution
gui.rs_ctr.debug.run1=manual execution
gui.rs_ctr.debug.step0=force cycle\n§4§ostable state
gui.rs_ctr.debug.step1=run cycle\n§2§ounstable
gui.rs_ctr.debug.reset=reset count
gui.rs_ctr.state.io=Signal IO\:
gui.rs_ctr.hex0=decimal format
gui.rs_ctr.hex1=hexadecimal format
gui.rs_ctr.interval=Interval
gui.rs_ctr.phase=Phase Offset
gui.rs_ctr.error1=§4Causal Loop\: input value depends on itself!\n§7§oInsert a §6§oFeedback Loop§7§o operator to fix this.
gui.rs_ctr.error2=§4incompatible data type
gui.rs_ctr.error3=§4missing input signal
gui.rs_ctr.error4=§4invalid identifier
gui.rs_ctr.error5=§4duplicate variable declaration
gui.rs_ctr.error6=§4conflicting variable data types!
gui.rs_ctr.error7=§4invalid value
gui.rs_ctr.error32=§4missing Processor
gui.rs_ctr.error33=§4circuit too complex\n§4for given Processor
gui.rs_ctr.error34=§4Processor doesn't\nsupport enough I/O
gui.rs_ctr.error64=§6highly recommended\n§6to label your IO ports
gui.rs_ctr.error65=§6Gate outputs are not used!
gui.rs_ctr.save_file=Export
gui.rs_ctr.load_file=Import
gui.rs_ctr.processor.run=manually trigger cycle
gui.rs_ctr.processor.power=Redstone exhaustion\:\n§e%.0f %%
gui.rs_ctr.assembler.stats=§c%d\n§b%d\n§9%d\n§f%d\n§e%.1f cyc\n§a%.1f c/s
gui.rs_ctr.assembler.stats4=§e%+d cap
gui.rs_ctr.assembler.stats5=§a%+d u/t
gui.rs_ctr.assembler.info=Processor Assembly\nRedstone Energy
gui.rs_ctr.assembler.info0=§7Complex circuitry requires complex §6Processors§7.\n§7There are 3 different types of §ecomplexity§7 related to different kinds of computational tasks and each can be increased by adding specific components to the §6Processor§7.\n§7However components take up §esize§7 and there is only a limited amount of it inside the Processor.\n§7Note that different components not only provide different types of §ecomplexity§7 but may also do that at different §esize§7 costs and have different §eRedstone Energy strenght§7. §oSee next tab.
gui.rs_ctr.assembler.info1=§7It seems §6Redstone§7 naturally builds up charge without any apparent energy source. §oIt's believed that it comes from radioactive decay.\n§7These charges are quite weak however, enough to perform simple logic computations but they quickly deplete when signals switch rapidly as can be seen in the burn out effect of §6Redstone Torches§7.\n§7Certain energetic materials may improve the charge strenght a bit whereas trying to miniaturize circuitry and reduce material costs severely weakens it, eventually up to a point where circuits can't run stable anymore without external power supply.\n§7§oThis is characterized by §e§olongest tick burst§7§o and §e§omax continuous tickrate§7.
gui.rs_ctr.mat3=remaining size
gui.rs_ctr.mat2=memory (bytes)
gui.rs_ctr.mat1=advanced Complexity
gui.rs_ctr.mat0=basic Complexity
gui.rs_ctr.mat5=max continuous tickrate
gui.rs_ctr.mat4=longest tick burst
gui.rs_ctr.max=scale upper limit
gui.rs_ctr.min=scale lower limit
gui.rs_ctr.uscale=Unit scale factor
gui.rs_ctr.style=Display Style
gui.rs_ctr.label=Label
gui.rs_ctr.unit=Unit
gui.rs_ctr.encoder0=raw segments encoding\:\n§78-bit per digit\n§e1\:§7 center\n§e2\:§7 uper left\n§e4\:§7 top\n§e8\:§7 upper right\n§e16\:§7 lower right\n§e32\:§7 bottom\n§e64\:§7 lower left\n§e128\:§7 decimal point
gui.rs_ctr.encoder1=signed raw segments encoding\:\n§7last 3 digits like §eraw segments encoding§7 using bits 0-23.\n§72 bits [24, 25] for first digit\:\n§e0\:§7 +\n§e1\:§7 +1\n§e2\:§7 -\n§e3\:§7 -1
gui.rs_ctr.encoder2=decimal encoding
gui.rs_ctr.encoder3=signed decimal encoding
gui.rs_ctr.encoder4=hexadecimal encoding
gui.rs_ctr.color=Display Color
gui.rs_ctr.dot=decimal point position
gui.rs_ctr.text=Text lines
gui.rs_ctr.align=Text alignment
gui.rs_ctr.v_off=OFF value
gui.rs_ctr.v_on=ON value
gui.rs_ctr.thr=Threshold value\n§oON when above

recipe.rs_ctr.circuit_mat=Processor Components
recipe.rs_ctr.battery=Capacitors
recipe.rs_ctr.sensors=Comparator tuning
recipe.rs_ctr.capacity=%.4u Charge
